import{d as s,e as N,b as h,p,i as D,a as pe,f as v,h as y,g as P,u as ze,j as R,k as F,l as j,m as Ht,n as Lt,A as Wt,q as Ge,s as Nt,t as Bt,v as Dt,w as Fe,x as Vt}from"./chunk-e5588fe7.js";function I(e){return typeof e!="object"||e===null?!1:Object.getPrototypeOf(e)===null?!0:e.constructor.name==="Object"}function Ut(e,t){if(!I(e))return!1;for(const n of Object.keys(e))if(!t.includes(n))return!1;return!0}function K(e){return(t,n)=>{const r=e(t),i=e(n);return r===i?0:r>i?-1:1}}function zt(e){return(t,n)=>{const r=e(t),i=e(n);return r===i?0:r<i?-1:1}}function k(e){return(t,n)=>{const r=e(t),i=e(n);if(s([!0,!1,null].includes(r)),s([!0,!1,null].includes(i)),r===i)return 0;if(r===!0||i===!1)return-1;if(i===!0||r===!1)return 1;s(!1)}}function Gt(e){return k(t=>{const n=e(t);return n===null?null:!n})}function Mt(e){return typeof e=="object"&&e!==null&&"then"in e&&N(e.then)}function $(e,t,n){return typeof e=="string"?xe(e.split(""),t,n).join(""):xe(e,t,n)}function xe(e,t,n){const r=[];let i=t>=0?t:e.length+t;s(i>=0&&i<=e.length);let o=n>=0?n:e.length+n;for(s(o>=0&&o<=e.length);!(i===o||(i===e.length&&(i=0),i===o));){const l=e[i];s(l!==void 0),r.push(l),i++}return r}function Yt(e){return typeof e=="object"&&e!==null&&Object.values(e).every(t=>typeof t=="string")}const Me=["http://","https://","tauri://"];function me(e){return Me.some(t=>e.startsWith(t))||e.startsWith("/")||e.startsWith(".")||e.startsWith("?")||e.startsWith("#")||e===""}function Jt(e,t){s(t.includes(" but ")),h(typeof e=="string",`${t} should be a string`),!me(e)&&(!e.startsWith("/")&&!e.includes(":")?h(!1,`${t} is ${p.cyan(e)} and it should be /${p.cyan(e)} instead (URL pathnames should start with a leading slash)`):h(!1,`${t} isn't a valid URL`))}function V(e,t){s(me(e)),s(t.startsWith("/"));const[n,...r]=e.split("#");s(n!==void 0);const i=["",...r].join("#")||null;s(i===null||i.startsWith("#"));const o=i===null?"":ae(i.slice(1)),[l,...a]=n.split("?");s(l!==void 0);const u=["",...a].join("?")||null;s(u===null||u.startsWith("?"));const c={},d={};Array.from(new URLSearchParams(u||"")).forEach(([O,z])=>{c[O]=z,d[O]=[...d.hasOwnProperty(O)?d[O]:[],z]});const{origin:f,pathname:g}=qt(l,t);s(f===null||f===ae(f)),s(g.startsWith("/")),s(f===null||e.startsWith(f));const m=l.slice((f||"").length);en(e,f,m,u,i);let{pathname:S,hasBaseServer:C}=Zt(g,t);return S=Kt(S),s(S.startsWith("/")),{origin:f,pathname:S,pathnameOriginal:m,hasBaseServer:C,search:c,searchAll:d,searchOriginal:u,hash:o,hashOriginal:i}}function ae(e){try{return decodeURIComponent(e)}catch{}try{return decodeURI(e)}catch{}return e}function Kt(e){return e=e.replace(/\s+$/,""),e=e.split("/").map(t=>ae(t).split("/").join("%2F")).join("/"),e}function qt(e,t){var n;s(!e.includes("?")&&!e.includes("#"));{const{origin:r,pathname:i}=Te(e);if(r)return{origin:r,pathname:i};s(i===e)}if(e.startsWith("/"))return{origin:null,pathname:e};{const r=typeof window<"u"?(n=window==null?void 0:window.document)==null?void 0:n.baseURI:void 0;let i;return r?i=Te(r.split("?")[0]).pathname:i=t,{origin:null,pathname:Xt(e,i)}}}function Te(e){if(Me.some(t=>e.startsWith(t))){const[t,n,r,...i]=e.split("/"),o=[t,n,r].join("/"),l=["",...i].join("/")||"/";return{origin:o,pathname:l}}else return{pathname:e,origin:null}}function Xt(e,t){const n=t.split("/"),r=e.split("/");let i=t.endsWith("/");e.startsWith(".")&&n.pop();for(const l in r){const a=r[l];a==""&&l==="0"||a!="."&&(a==".."?n.pop():(i=!1,n.push(a)))}let o=n.join("/");return i&&!o.endsWith("/")&&(o+="/"),o.startsWith("/")||(o="/"+o),o}function Qt(e){s(e.startsWith("/")),s(!e.includes("?")),s(!e.includes("#"))}function Zt(e,t){Qt(e),s(ye(t));let n=e;if(s(n.startsWith("/")),s(t.startsWith("/")),t==="/")return{pathname:e,hasBaseServer:!0};let r=t;return t.endsWith("/")&&n===$(t,0,-1)&&(r=$(t,0,-1),s(n===r)),n.startsWith(r)?(s(n.startsWith("/")||n.startsWith("http")),s(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),s(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:e,hasBaseServer:!1}}function ye(e){return e.startsWith("/")}function en(e,t,n,r,i){const o=tn(t,n,r,i);s(e===o)}function tn(e,t,n,r){return`${e||""}${t}${n||""}${r||""}`}function Ye(){s(D())}function nn(){Ye(),pe()}function rn(){Ye()}function be(e){const t=window.location.href,{searchOriginal:n,hashOriginal:r,pathname:i}=V(t,"/");let o;return e!=null&&e.withoutHash?o=`${i}${n||""}`:o=`${i}${n||""}${r||""}`,s(o.startsWith("/")),o}rn();function on(){var r,i,o,l;const e=!!((i=(r=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:r.renderers)!=null&&i.size),t=!!((l=(o=window.__REACT_DEVTOOLS_GLOBAL_HOOK__)==null?void 0:o.rendererInterfaces)!=null&&l.size),n=!!window.__vite_plugin_react_preamble_installed__;return e||t||n}function Je(e,t){const n=Object.keys,r=typeof e;return e&&t&&r==="object"&&r===typeof t?n(e).length===n(t).length&&n(e).every(o=>Je(e[o],t[o])):e===t}function sn(e,t){return v(e)&&v(t)&&e.constructor===t.constructor&&Je({...e,stack:null},{...t,stack:null})&&t.message===t.message}function q(e){window.location.href=e}function an(e){return new Promise(t=>setTimeout(t,e))}function ln(e,t){let n=!1;return()=>{n||(n=!0,setTimeout(()=>{n=!1,e()},t))}}function Ke(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="hidden"&&e()})}function un(e){window.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&e()})}function cn(e){return!e.startsWith("/")&&!e.startsWith(".")&&!e.startsWith("?")&&e!==""}nn();const fn=[{is:e=>e===void 0,match:e=>e==="!undefined",serialize:()=>"!undefined",deserialize:()=>{}},{is:e=>e===1/0,match:e=>e==="!Infinity",serialize:()=>"!Infinity",deserialize:()=>1/0},{is:e=>e===-1/0,match:e=>e==="!-Infinity",serialize:()=>"!-Infinity",deserialize:()=>-1/0},{is:e=>typeof e=="number"&&isNaN(e),match:e=>e==="!NaN",serialize:()=>"!NaN",deserialize:()=>NaN},{is:e=>e instanceof Date,match:e=>e.startsWith("!Date:"),serialize:e=>"!Date:"+e.toISOString(),deserialize:e=>new Date(e.slice(6))},{is:e=>typeof e=="bigint",match:e=>e.startsWith("!BigInt:"),serialize:e=>"!BigInt:"+e.toString(),deserialize:e=>{if(typeof BigInt>"u")throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");return BigInt(e.slice(8))}},{is:e=>e instanceof RegExp,match:e=>e.startsWith("!RegExp:"),serialize:e=>"!RegExp:"+e.toString(),deserialize:e=>{e=e.slice(8);const t=e.match(/\/(.*)\/(.*)?/),n=t[1],r=t[2];return new RegExp(n,r)}},{is:e=>e instanceof Map,match:e=>e.startsWith("!Map:"),serialize:(e,t)=>"!Map:"+t(Array.from(e.entries())),deserialize:(e,t)=>new Map(t(e.slice(5)))},{is:e=>e instanceof Set,match:e=>e.startsWith("!Set:"),serialize:(e,t)=>"!Set:"+t(Array.from(e.values())),deserialize:(e,t)=>new Set(t(e.slice(5)))},{is:e=>typeof e=="string"&&e.startsWith("!"),match:e=>e.startsWith("!"),serialize:e=>"!"+e,deserialize:e=>e.slice(1)}];function ee(e){const t=JSON.parse(e);return qe(t)}function qe(e){return typeof e=="string"?dn(e):(typeof e=="object"&&e!==null&&Object.entries(e).forEach(([t,n])=>{e[t]=qe(n)}),e)}function dn(e){for(const{match:t,deserialize:n}of fn)if(t(e))return n(e,ee);return e}function gn(){const e="vike_pageContext",t=document.getElementById(e);h(t,`The element #${e} (which Vike automatically injects into the HTML) is missing from the DOM. This may happen if your HTML is malformed. Make sure your HTML isn't malformed, and make sure you don't remove #${e} from the HTML nor from the DOM.`);const n=t.textContent;s(n);const r=ee(n);return s(y(r,"_pageId","string")),P(r,{_hasPageContextFromServer:!0}),r}function hn(e,t){return e.toLowerCase()<t.toLowerCase()?-1:e.toLowerCase()>t.toLowerCase()?1:0}const pn=e=>e!=null;function Ie(e){return"["+e.map(t=>"'"+t+"'").join(", ")+"]"}function Xe(e){const t=n=>`Not a posix path: ${n}`;s(e!==null,t("null")),s(typeof e=="string",t(`typeof path === ${JSON.stringify(typeof e)}`)),s(e!=="",t("(empty string)")),s(e),s(!e.includes("\\"),t(e))}function re(e,t){const n=Object.getOwnPropertyDescriptor(e,t);return!!n&&!("value"in n)&&!!n.get}function mn(e){return[null,void 0].includes(e)?String(e):["boolean","number","string"].includes(typeof e)?JSON.stringify(e):null}function yn(e){return e.replace(/[/\-\\^$*+?.()|[\]{}]/g,"\\$&")}function L(e){Xe(e)}function Pe(e,t){return Ze(e,t,!0)}function Qe(e,t){return Ze(e,t,!1)}function Ze(e,t,n){const r=n?"CLIENT_ONLY":"SERVER_ONLY",i=e.filter(m=>m.isRelevant(t)&&m.fileType!==".page.route").sort(bn(n,t)),o=m=>{const S=i.filter(O=>O.pageId===t&&O.isEnv(m?"CLIENT_AND_SERVER":r));h(S.length<=1,`Merge the following files into a single file: ${S.map(O=>O.filePath).join(" ")}`);const C=S[0];return s(C===void 0||!C.isDefaultPageFile),C},l=o(!1),a=o(!0),u=m=>i.filter(S=>S.isRendererPageFile&&S.isEnv(m?"CLIENT_AND_SERVER":r))[0],c=u(!1),d=u(!0),f=i.filter(m=>m.isDefaultPageFile&&!m.isRendererPageFile&&(m.isEnv(r)||m.isEnv("CLIENT_AND_SERVER")));return[l,a,...f,c,d].filter(pn)}function bn(e,t){const n=e?"CLIENT_ONLY":"SERVER_ONLY",r=-1,i=1,o=0;return(l,a)=>{if(!l.isDefaultPageFile&&a.isDefaultPageFile)return r;if(!a.isDefaultPageFile&&l.isDefaultPageFile)return i;{const u=l.isRendererPageFile,c=a.isRendererPageFile;if(!u&&c)return r;if(!c&&u)return i;s(u===c)}{const u=ke(t,l.filePath),c=ke(t,a.filePath);if(u<c)return r;if(c<u)return i;s(u===c)}{if(l.isEnv(n)&&a.isEnv("CLIENT_AND_SERVER"))return r;if(a.isEnv(n)&&l.isEnv("CLIENT_AND_SERVER"))return i}return o}}function ke(e,t){L(e),L(t);let n=0;for(;n<e.length&&n<t.length&&e[n]===t[n];n++);const r=e.slice(n),i=t.slice(n),o=r.split("/").length,l=i.split("/").length;return o+l}async function Pn(e,t){const r=Qe(e,t).filter(o=>o.fileType===".page.server");return await Promise.all(r.map(async o=>{o.exportNames||(s(o.loadExportNames,t),await o.loadExportNames())})),{hasOnBeforeRenderServerSideOnlyHook:r.some(({exportNames:o})=>(s(o),o.includes("onBeforeRender")))}}function et(e,t){if(t.length>0){const r=t.filter(i=>i.isErrorPage);return r.length===0?null:(h(r.length===1,"Only one error page can be defined"),r[0].pageId)}const n=ze(e.map(({pageId:r})=>r).filter(r=>U(r)));if(h(n.length<=1,`Only one _error.page.js is allowed, but found several: ${n.join(" ")}`),n.length>0){const r=n[0];return s(r),r}return null}function U(e,t){return s(!e.includes("\\")),e.includes("/_error")}function Sn(e,t){if(t.length>0){const n=t.find(r=>r.pageId===e);return s(n),!!n.isErrorPage}else return U(e)}function wn(e,t){if(!e)return null;let[n,...r]=e;if(!n||r.length===0&&["*","default",t].includes(n))return null;s(n!=="*");let i="",o="";return n==="default"?i="export default":(i="export",r=[n,...r]),r.forEach(a=>{i=`${i} { ${a}`,o=` }${o}`}),i+o}function Se(e,t,{definedAt:n}){const r=tt(n,t),i=r==="internally"?r:`at ${r}`;let o=`${t}`;return`${e} ${p.cyan(o)} defined ${i}`}function tt(e,t){if("isComputed"in e)return"internally";let n;return"files"in e?n=e.files:n=[e],s(n.length>=1),n.map(i=>{const{filePathToShowToUser:o,fileExportPathToShowToUser:l}=i;let a=o;const u=wn(l,t);return u&&(a=`${a} > ${p.cyan(u)}`),a}).join(" / ")}function W(e,t,n){const r=vn(e,t);if(r===null)return null;const{value:i,definedAt:o}=r;return n&&Rn(i,n,t,o),r}function Rn(e,t,n,r){s(e!==null);const i=typeof e;if(i===t)return;const o=mn(e),l=o!==null?`value ${p.cyan(o)}`:`type ${p.cyan(i)}`,u=`${Se("Config",n,{definedAt:r})} has an invalid ${l}: it should be a ${p.cyan(t)} instead`;h(!1,u)}function vn(e,t){const n=e.configValues[t];return!n||n.value===null?null:n}function nt(e,t){const n=t.find(r=>r.pageId===e);return s(t.length>0),s(n),n}function rt({definedAt:e}){if("isComputed"in e||"files"in e)return null;const{filePathToShowToUser:t}=e;return s(t),t}function _n({definedAt:e}){const t=rt({definedAt:e});return s(t),t}function T(e,t){if(!(t in e.exports))return null;const{hooksTimeout:n}=e.config,r=Cn(n,t),i=e.exports[t],o=e.exportsAll[t][0];if(s(o.exportValue===i),i===null)return null;const l=o.filePath;return s(l),s(!l.endsWith(" ")),it(i,{hookName:t,hookFilePath:l}),{hookFn:i,hookName:t,hookFilePath:l,hookTimeout:r}}function On(e,t){const n=e.configValues[t];if(!n)return null;const r=n.value;if(!r)return null;const i=_n(n);s(i),it(r,{hookName:t,hookFilePath:i});const o=te(t);return{hookFn:r,hookName:t,hookFilePath:i,hookTimeout:o}}function ie(e,t){T(e,t)}function it(e,{hookName:t,hookFilePath:n}){s(t&&n),s(!t.endsWith(")")),h(N(e),`Hook ${t}() defined by ${n} should be a function`)}function Cn(e,t){const n=En(e);if(n===!1)return{error:!1,warning:!1};const r=n[t],i=te(t);return(r==null?void 0:r.error)!==void 0&&(i.error=r.error),(r==null?void 0:r.warning)!==void 0&&(i.warning=r.warning),i}function En(e){if(e===void 0)return{};if(e===!1)return!1;h(v(e),`Setting ${p.cyan("hooksTimeout")} should be ${p.cyan("false")} or an object`);const t={};return Object.entries(e).forEach(([n,r])=>{if(r===!1){t[n]={error:!1,warning:!1};return}h(v(r),`Setting ${p.cyan(`hooksTimeout.${n}`)} should be ${p.cyan("false")} or an object`);const[i,o]=["error","warning"].map(l=>{const a=r[l];if(a===void 0||a===!1)return a;const u=`Setting ${p.cyan(`hooksTimeout.${n}.${l}`)} should be`;return h(typeof a=="number",`${u} ${p.cyan("false")} or a number`),h(a>0,`${u} a positive number`),a});t[n]={error:i,warning:o}}),t}function te(e){return e==="onBeforeRoute"?{error:5*1e3,warning:1*1e3}:e==="onPrerenderStart"||e==="onBeforePrerenderStart"||e==="onBeforePrerender"||e==="prerender"?{error:10*60*1e3,warning:30*1e3}:{error:30*1e3,warning:4*1e3}}function $n(e){const t=Object.entries(e);for(const n in e)delete e[n];t.sort(([n],[r])=>hn(n,r)).forEach(([n,r])=>{e[n]=r})}function Fn(e){xn(e),Tn(e)}function xn(e){Sn(e._pageId,e._pageConfigs)&&s(y(e,"is404","boolean"))}function Tn(e){if(e.is404===void 0||e.is404===null)return;const t=e.pageProps||{};if(!v(t)){R(!1,"pageContext.pageProps should be an object",{showStackTrace:!0,onlyOnce:!0});return}t.is404=t.is404||e.is404,e.pageProps=t}const In="not-serializable",X=F("getPageContextProxyForUser.ts",{});function kn(e){return s([!0,!1].includes(e._hasPageContextFromServer)),s([!0,!1].includes(e._hasPageContextFromClient)),new Proxy(e,{get(t,n){const r=e[n],i=JSON.stringify(n);return h(r!==In,`pageContext[${i}] couldn't be serialized and, therefore, is missing on the client-side. Check the server logs for more information.`),An(e,n),r}})}function An(e,t){if(X.prev===t||X.prev==="__v_raw"||(Ln(t),t in e)||Hn(t))return;const n=JSON.stringify(t);e._hasPageContextFromServer&&!e._hasPageContextFromClient&&h(!1,`pageContext[${n}] isn't available on the client-side because ${n} is missing in passToClient, see https://vike.dev/passToClient`)}const jn=["then","toJSON"];function Hn(e){return!!(jn.includes(e)||typeof e=="symbol"||typeof e!="string"||e.startsWith("__v_"))}function Ln(e){X.prev=e,window.setTimeout(()=>{X.prev=void 0},0)}function we(e,t){if(t){const i=e;s([!0,!1].includes(i.isHydration)),s([!0,!1,null].includes(i.isBackwardNavigation))}else{const i=e;s(i.isHydration===!0),s(i.isBackwardNavigation===null)}s("config"in e),s("configEntries"in e),s("exports"in e),s("exportsAll"in e),s("pageExports"in e),s(v(e.pageExports));const n=e.exports.Page;P(e,{Page:n}),Wn(e),$n(e);const r=kn(e);return Fn(e),r}function Wn(e){Object.entries(e).forEach(([t,n])=>{delete e[t],e[t]=n})}const Nn=["js","ts","cjs","cts","mjs","mts","jsx","tsx","cjsx","ctsx","mjsx","mtsx"],ot=["vue","svelte","marko","md","mdx"],Bn=[...Nn,...ot];function st(e){const t=Bn.some(n=>e.endsWith("."+n));return s(!Dn(e)||t),t}function Dn(e){return/\.(c|m)?(j|t)sx?$/.test(e)}function Vn(e){return ot.some(t=>e.endsWith("."+t))}const Un=["clientRouting"];function zn(e){Un.forEach(t=>{if(s(e.fileExports),!(t in e.fileExports))return;const n=`The value of \`${t}\` is only allowed to be \`true\`.`;h(e.fileExports[t]!==!1,`${e.filePath} has \`export { ${t} }\` with the value \`false\` which is prohibited: remove \`export { ${t} }\` instead. (${n})`),h(e.fileExports[t]===!0,`${e.filePath} has \`export { ${t} }\` with a forbidden value. ${n}`)})}const at=["render","clientRouting","prerender","doNotPrerender"];function Gn(e,t){h(!at.includes(e),`${t} has \`export default { ${e} }\` which is prohibited, use \`export { ${e} }\` instead.`)}function Mn(e,t){const n={},r={},i={};e.forEach(a=>{Yn(a).forEach(({exportName:c,exportValue:d,isFromDefaultExport:f})=>{s(c!=="default"),i[c]=i[c]??[],i[c].push({exportValue:d,exportSource:`${a.filePath} > ${f?`\`export default { ${c} }\``:`\`export { ${c} }\``}`,filePath:a.filePath,_filePath:a.filePath,_fileType:a.fileType,_isFromDefaultExport:f})})}),t&&Object.entries(t.configValues).forEach(([a,u])=>{const{value:c}=u,d=rt(u),f=Se("Config",a,u);r[a]=r[a]??c,n[a]=n[a]??[],s(n[a].length===0),n[a].push({configValue:c,configDefinedAt:f,configDefinedByFile:d});const g=a;i[g]=i[g]??[],i[g].push({exportValue:c,exportSource:f,filePath:d,_filePath:d,_fileType:null,_isFromDefaultExport:null})});const o=Jn(),l={};return Object.entries(i).forEach(([a,u])=>{u.forEach(({exportValue:c,_fileType:d,_isFromDefaultExport:f})=>{l[a]=l[a]??c,d===".page"&&!f&&(a in o||(o[a]=c))})}),s(!("default"in l)),s(!("default"in i)),{config:r,configEntries:n,exports:l,exportsAll:i,pageExports:o}}function Yn(e){const{filePath:t,fileExports:n}=e;s(n),s(st(t));const r=[];return Object.entries(n).sort(Gt(([i])=>i==="default")).forEach(([i,o])=>{let l=i==="default";if(l)if(Vn(t))i="Page";else{h(v(o),`The ${p.cyan("export default")} of ${t} should be an object.`),Object.entries(o).forEach(([a,u])=>{Gn(a,t),r.push({exportName:a,exportValue:u,isFromDefaultExport:l})});return}r.push({exportName:i,exportValue:o,isFromDefaultExport:l})}),r.forEach(({exportName:i,isFromDefaultExport:o})=>{s(!(o&&at.includes(i)))}),r}function Jn(){return new Proxy({},{get(...e){return D()||R(!1,"`pageContext.pageExports` is outdated. Use `pageContext.exports` instead, see https://vike.dev/exports",{onlyOnce:!0,showStackTrace:!0}),Reflect.get(...e)}})}function Kn(e){const t=".page.",n=$(e.split(t),0,-1).join(t);return s(!n.includes("\\")),n}const qn=[".page",".page.server",".page.route",".page.client",".css"];function Xn(e){if(Xe(e),e.endsWith(".css"))return".css";s(st(e),e);const n=e.split("/").slice(-1)[0].split("."),r=n.slice(-3)[0],i=n.slice(-2)[0];if(i==="page")return".page";if(s(r==="page",e),i==="server")return".page.server";if(i==="client")return".page.client";if(i==="route")return".page.route";s(!1,e)}function lt(e){const t=o=>i.pageId===o||i.isDefaultPageFile&&(Ae(i.filePath)||Qn(o,i.filePath)),n=Xn(e),i={filePath:e,fileType:n,isEnv:o=>{if(s(n!==".page.route"),o==="CLIENT_ONLY")return n===".page.client"||n===".css";if(o==="SERVER_ONLY")return n===".page.server";if(o==="CLIENT_AND_SERVER")return n===".page";s(!1)},isRelevant:t,isDefaultPageFile:le(e),isRendererPageFile:n!==".css"&&le(e)&&Ae(e),isErrorPageFile:U(e),pageId:Kn(e)};return i}function le(e){return L(e),U(e)?!1:e.includes("/_default")}function Ae(e){return L(e),e.includes("/renderer/")}function Qn(e,t){L(e),L(t),s(!e.endsWith("/")),s(!t.endsWith("/")),s(le(t));const n=$(t.split("/"),0,-1).filter(r=>r!=="_default").join("/");return e.startsWith(n)}function Zn(e){s(Array.isArray(e)),e.forEach(t=>{s(v(t)),s(y(t,"pageId","string")),s(y(t,"routeFilesystem")),s(y(t,"configValuesSerialized")),s(y(t,"configValuesImported"))})}function er(e){s(y(e,"configValuesImported"))}const tr=["$$registrations","_rerender_only"],nr=[".md",".mdx"];function rr(e,t,n){ir(e,t,n)}function ir(e,t,n){const i=Object.keys(e).filter(l=>!tr.includes(l)),o=i.filter(l=>l!=="default"&&l!==n);if(o.length===0){if(i.length===1)return;{s(i.length===0);let l=`${t} doesn't export any value, but it should have a ${p.cyan("export default")}`;n&&(l+=` or ${p.cyan(`export { ${n} }`)}`),h(!1,l)}}else if(n){if(nr.some(l=>t.endsWith(l)))return;o.forEach(l=>{R(!1,`${t} should have only a single export: move ${p.cyan(`export { ${l} }`)} to +config.h.js or its own +${o}.js`,{onlyOnce:!0})})}else{const l=o.join(", ");h(!1,`${t} replace ${p.cyan(`export { ${l} }`)} with ${p.cyan(`export default { ${l} }`)}`)}}function ue(e){const t={},n=(r,i,o,l)=>{t[r]={value:i,definedAt:{filePathToShowToUser:o,fileExportPathToShowToUser:[r,"default"].includes(l)?[]:[l]}},or(i,r,o)};return e.forEach(r=>{if(r.isValueFile){const{exportValues:i,importPath:o,configName:l}=r;l!=="client"&&rr(i,o,l),Object.entries(i).forEach(([a,u])=>{const c=a!=="default",d=c?a:r.configName;c&&d in t||n(d,u,o,a)})}else{const{configName:i,importPath:o,exportValue:l,exportName:a}=r;n(i,l,o,a)}}),t}function or(e,t,n){s(!n.includes("+config."))}function ut(e){const t={};return Object.entries(e).forEach(([n,r])=>{const{valueSerialized:i,definedAt:o}=r;s(i),s(!t[n]),t[n]={value:ee(i),definedAt:o}}),t}function sr(e,t){const n=e.map(i=>{const o={};{const{configValuesSerialized:d}=i,f=ut(d);Object.assign(o,f)}{const{configValuesImported:d}=i,f=ue(d);Object.assign(o,f)}const{pageId:l,isErrorPage:a,routeFilesystem:u,loadConfigValuesAll:c}=i;return ar(o),{pageId:l,isErrorPage:a,routeFilesystem:u,configValues:o,loadConfigValuesAll:c}}),r={configValues:{}};{const i=ue(t.configValuesImported);Object.assign(r.configValues,i)}return{pageConfigs:n,pageConfigGlobal:r}}function ar(e){const t="route",n=e[t];if(!n)return;const{value:r}=n,i=typeof r,o=Se("Config",t,n);h(i==="string"||N(r),`${o} has an invalid type '${i}': it should be a string or a function instead, see https://vike.dev/route`)}function lr(e){s(y(e,"isGeneratedFile")),s(e.isGeneratedFile!==!1,"vike was re-installed(/re-built). Restart your app."),s(e.isGeneratedFile===!0,`\`isGeneratedFile === ${e.isGeneratedFile}\``),s(y(e,"pageFilesLazy","object")),s(y(e,"pageFilesEager","object")),s(y(e,"pageFilesExportNamesLazy","object")),s(y(e,"pageFilesExportNamesEager","object")),s(y(e.pageFilesLazy,".page")),s(y(e.pageFilesLazy,".page.client")||y(e.pageFilesLazy,".page.server")),s(y(e,"pageFilesList","string[]")),s(y(e,"pageConfigsSerialized")),s(y(e,"pageConfigGlobalSerialized"));const{pageConfigsSerialized:t,pageConfigGlobalSerialized:n}=e;Zn(t),er(n);const{pageConfigs:r,pageConfigGlobal:i}=sr(t,n),o={};G(e.pageFilesLazy).forEach(({filePath:a,pageFile:u,globValue:c})=>{u=o[a]=o[a]??u;const d=c;je(d),u.loadFile=async()=>{"fileExports"in u||(u.fileExports=await d(),zn(u))}}),G(e.pageFilesExportNamesLazy).forEach(({filePath:a,pageFile:u,globValue:c})=>{u=o[a]=o[a]??u;const d=c;je(d),u.loadExportNames=async()=>{if(!("exportNames"in u)){const f=await d();h("exportNames"in f,"You seem to be using Vite 2 but the latest vike versions only work with Vite 3"),s(y(f,"exportNames","string[]"),u.filePath),u.exportNames=f.exportNames}}}),G(e.pageFilesEager).forEach(({filePath:a,pageFile:u,globValue:c})=>{u=o[a]=o[a]??u;const d=c;s(v(d)),u.fileExports=d}),G(e.pageFilesExportNamesEager).forEach(({filePath:a,pageFile:u,globValue:c})=>{u=o[a]=o[a]??u;const d=c;s(v(d)),s(y(d,"exportNames","string[]"),u.filePath),u.exportNames=d.exportNames}),e.pageFilesList.forEach(a=>{o[a]=o[a]??lt(a)});const l=Object.values(o);return l.forEach(({filePath:a})=>{s(!a.includes("\\"))}),{pageFiles:l,pageConfigs:r,pageConfigGlobal:i}}function G(e){const t=[];return Object.entries(e).forEach(([n,r])=>{s(qn.includes(n)),s(v(r)),Object.entries(r).forEach(([i,o])=>{const l=lt(i);s(l.fileType===n),t.push({filePath:i,pageFile:l,globValue:o})})}),t}function je(e){s(N(e))}const x=F("setPageFiles.ts",{});function Ei(e){const{pageFiles:t,pageConfigs:n,pageConfigGlobal:r}=lr(e);x.pageFilesAll=t,x.pageConfigs=n,x.pageConfigGlobal=r}async function ur(e,t){e?(s(!x.pageFilesGetter),s(t===void 0)):(s(x.pageFilesGetter),s(typeof t=="boolean"),(!x.pageFilesAll||!t)&&await x.pageFilesGetter());const{pageFilesAll:n,pageConfigs:r,pageConfigGlobal:i}=x;s(n&&r&&i);const o=cr(n,r);return{pageFilesAll:n,allPageIds:o,pageConfigs:r,pageConfigGlobal:i}}function cr(e,t){const n=e.filter(({isDefaultPageFile:o})=>!o).map(({pageId:o})=>o),r=ze(n),i=t.map(o=>o.pageId);return[...r,...i]}function ct(e,t){const n=e.filter(i=>i.pageId===t);return s(n.length<=1),n[0]??null}async function fr(e,t){if("isAllLoaded"in e&&!t)return e;const n=await e.loadConfigValuesAll();{const{configValuesImported:r}=n,i=ue(r);Object.assign(e.configValues,i)}{const{configValuesSerialized:r}=n,i=ut(r);Object.assign(e.configValues,i)}return P(e,{isAllLoaded:!0}),e}const ft="__whileFetchingAssets";async function Q(e,t){const n=Pe(t._pageFilesAll,e),r=ct(t._pageConfigs,e);let i;const o=!1;try{i=(await Promise.all([r&&fr(r,o),...n.map(m=>{var S;return(S=m.loadFile)==null?void 0:S.call(m)})]))[0]}catch(g){throw dr(g)&&Object.assign(g,{[ft]:!0}),g}const{config:l,configEntries:a,exports:u,exportsAll:c,pageExports:d}=Mn(n,i);return{config:l,configEntries:a,exports:u,exportsAll:c,pageExports:d,_pageFilesLoaded:n}}function Re(e){return e?e[ft]===!0:!1}function dr(e){return e instanceof Error?["Failed to fetch dynamically imported module","error loading dynamically imported module","Importing a module script failed","error resolving module specifier","failed to resolve module"].some(n=>e.message.toLowerCase().includes(n.toLowerCase())):!1}const He=["urlPathname","urlParsed"],gr=["Page","pageExports","exports"];function dt(e){[...gr,...He].forEach(n=>{n in e&&(He.includes(n)?(s(n.startsWith("url")),R(!1,`pageContext.${n} is already available in the browser when using Client Routing; adding '${n}' to passToClient has no effect`,{onlyOnce:!0})):R(!1,`pageContext.${n} is a built-in that cannot be overriden; adding '${n}' to passToClient has no effect`,{onlyOnce:!0}),delete e[n])})}const hr="/";function pr(e,t,n){const{pathnameOriginal:r,searchOriginal:i,hashOriginal:o}=V(e,hr);e.startsWith("/")&&s(e===`${r}${i||""}${o||""}`,{url:e});const l=r.endsWith("/");let a;return n&&r!=="/"?(l?a=$(r,0,-1):a=r,s(!a.endsWith("/"),{url:e}),s(a!=="")):a=r+(l?"":"/")+"index",s(a),a=a+t,`${a}${i||""}${o||""}`}const mr=".pageContext.json",yr=!1;function br(e){return pr(e,mr,yr)}function gt(e,{hookName:t,hookFilePath:n}){if(e==null)return;s(!t.endsWith(")"));const r=`The ${p.cyan("pageContext")} object provided by the ${t}() hook defined by ${n}`;h(v(e),`${r} should be an object (but it's ${p.cyan(`typeof pageContext === ${JSON.stringify(typeof e)}`)} instead)`),h(!("_objectCreatedByVike"in e),`${r} shouldn't be the whole ${p.cyan("pageContext")} object, see https://vike.dev/pageContext-manipulation#do-not-return-entire-pagecontext`),R(!("_pageId"in e),`${r} sets ${p.cyan("pageContext._pageId")} which means that Vike's routing is overriden. This is an experimental feature: make sure to contact a vike maintainer before using this.`,{onlyOnce:!0}),h(!("is404"in e),`${r} sets ${p.cyan("pageContext.is404")} which is forbidden, use ${p.cyan("throw render()")} instead, see https://vike.dev/render`)}function Pr(e,t,n){s(!n.endsWith(" "));const r=[],i=Object.keys(e);for(const o of i)t.includes(o)||r.push(o);h(r.length===0,[n,"returned an object with following unknown keys:",Ie(r)+".","Only following keys are allowed:",Ie(t)+"."].join(" "))}function Sr(e,t){if(e==null)return;const n=`The onBeforeRender() hook defined by ${t}`;h(I(e),`${n} should return a plain JavaScript object, ${p.cyan("undefined")}, or ${p.cyan("null")}`),Pr(e,["pageContext"],n),e.pageContext&&gt(e.pageContext,{hookName:"onBeforeRender",hookFilePath:t})}async function wr(e,t){let n;if(e._pageFilesAll.length>0?(s(e._pageConfigs.length===0),n=Rr(e._pageId,e._pageFilesAll)):n=T(e,"guard"),!n)return;const r=n.hookFn;let i=e;const o=t(e);o&&(i=o);const l=await j(()=>r(i),n);h(l===void 0,`The guard() hook of ${n.hookFilePath} returns a value, but guard() doesn't accept any return value`)}function Rr(e,t){const n=t.find(u=>u.pageId===e&&u.fileType===".page.route");if(!n)return null;const{filePath:r,fileExports:i}=n;s(i);const o=i.guard;if(!o)return null;const l=r,a=te("guard");return h(N(o),`guard() defined by ${l} should be a function`),{hookFn:o,hookName:"guard",hookFilePath:l,hookTimeout:a}}const ht=F("router/getPageContext.ts",{});async function vr(e){const t=gn();dt(t),P(t,{isHydration:!0,_hasPageContextFromClient:!1}),P(t,await Q(t._pageId,e));{const n={...e,...t};if(bt(n)){const r=await mt(n);P(t,r)}}return yt(t),t}async function _r(e){const t=et(e._pageFilesAll,e._pageConfigs);if(!t)throw new Error("No error page defined.");const n={isHydration:!1,_pageId:t};return P(n,await pt({...e,...n},!0)),n}async function Or(e){const t={isHydration:!1,_pageId:e._pageId};return P(t,await pt({...e,...t},!1)),yt(t),t}async function pt(e,t){let n={};P(n,{_hasPageContextFromClient:!1}),P(n,await Q(e._pageId,e));let r=!1;if(!t&&await Cr({...e,...n})){const i=await $r(e);if(r=!0,!i._isError)P(n,i);else{const o=et(e._pageFilesAll,e._pageConfigs);s(o),n={},P(n,{_hasPageContextFromClient:!1,isHydration:!1,_pageId:o}),P(n,await Q(n._pageId,e)),s(y(i,"is404","boolean")),s(y(i,"pageProps","object")),s(y(i.pageProps,"is404","boolean")),s(!("serverSideError"in i)),P(n,i)}}else P(n,{_hasPageContextFromServer:!1}),t||await wr({...e,...n},i=>we(i,!0));{const i={...e,...n};if(bt(i)||!r){const o=await mt(i);P(n,o)}else s(r)}return n}async function mt(e){const t=T(e,"onBeforeRender");if(!t)return{_hasPageContextFromClient:!1};const n=t.hookFn,r={_hasPageContextFromClient:!0},i=we({...e,...r},!0),o=await j(()=>n(i),t);Sr(o,t.hookFilePath);const l=o==null?void 0:o.pageContext;return P(r,l),r}function yt(e){e._pageContextInitHasClientData&&(ht.pageContextInitHasClientData=!0)}async function Cr(e){return!!ht.pageContextInitHasClientData||await Er(e)}async function Er(e){var t;if(e._pageConfigs.length>0){const n=nt(e._pageId,e._pageConfigs),r=((t=W(n,"onBeforeRenderEnv"))==null?void 0:t.value)??{};return s(v(r)),!!r.server&&!r.client}else{const{hasOnBeforeRenderServerSideOnlyHook:n}=await Pn(e._pageFilesAll,e._pageId);return n}}function bt(e){var t;if(e._pageConfigs.length>0){const n=nt(e._pageId,e._pageConfigs),r=((t=W(n,"onBeforeRenderEnv"))==null?void 0:t.value)??{};return s(v(r)),!!r.client&&!r.server}else return!1}async function $r(e){const t=br(e._urlRewrite??e.urlOriginal),n=await fetch(t);{const o=n.headers.get("content-type"),l="application/json",a=o&&o.includes(l);if(!a&&n.status===404)throw q(e.urlOriginal),xr();h(a,`Wrong Content-Type for ${t}: it should be ${l} but it's ${o} instead. Make sure to properly use pageContext.httpResponse.headers, see https://vike.dev/renderPage`)}const r=await n.text(),i=ee(r);if(s(v(i)),"serverSideError"in i)throw Ht("The pageContext object couldn't be fetched from the server as an error occurred on the server-side. Check your server logs.");if(Lt(i))throw Wt(i);return s(y(i,"_pageId","string")),dt(i),P(i,{_hasPageContextFromServer:!0}),i}function Fr(e){return v(e)&&!!e._alreadyServerSideRouted}function xr(){const e=new Error("Page doesn't exist");return Object.assign(e,{_alreadyServerSideRouted:!0}),e}function Pt(e,t=!0){s(e.urlOriginal),"urlPathname"in e&&(s(typeof e.urlPathname=="string"),s(re(e,"urlPathname"))),"urlParsed"in e&&s(re(e,"urlParsed")),"url"in e&&s(re(e,"url")),Object.defineProperty(e,"urlPathname",{get:wt,enumerable:t,configurable:!0}),Object.defineProperty(e,"url",{get:Tr,enumerable:!1,configurable:!0}),Object.defineProperty(e,"urlParsed",{get:Ir,enumerable:t,configurable:!0})}function St(e){let t=e._urlHandler;t||(t=i=>i);let n=e._urlRewrite??e.urlLogical??e.urlOriginal;n=t(n);const r=e._baseServer;return s(n&&typeof n=="string"),s(r.startsWith("/")),V(n,r)}function wt(){const{pathname:e}=St(this),t=e;return s(t.startsWith("/")),t}function Tr(){return R(!1,"`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vike.dev/migration/0.4.23 for more information.)",{onlyOnce:!0,showStackTrace:!0}),wt.call(this)}function Ir(){const e=St(this),{origin:t,pathname:n,pathnameOriginal:r,search:i,searchAll:o,searchOriginal:l,hash:a,hashOriginal:u}=e,c=D(),d=g=>{R(c,`pageContext.urlParsed.${g} isn't available on the server-side (HTTP requests don't include the URL hash by design)`,{onlyOnce:!0,showStackTrace:!0})},f={origin:t,pathname:n,pathnameOriginal:r,search:i,searchAll:o,searchOriginal:l,get hash(){return d("hash"),a},get hashOriginal(){return d("hashOriginal"),u},get hashString(){return R(!1,"pageContext.urlParsed.hashString has been renamed to pageContext.urlParsed.hashOriginal",{onlyOnce:!0,showStackTrace:!0}),d("hashString"),u},get searchString(){return R(!1,"pageContext.urlParsed.searchString has been renamed to pageContext.urlParsed.searchOriginal",{onlyOnce:!0,showStackTrace:!0}),l}};return M(f,"hashString"),M(f,"searchString"),c||(M(f,"hash"),M(f,"hashOriginal")),f}function M(e,t){const n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(e,t,{...n,enumerable:!1})}function kr(e){s(typeof e.urlOriginal=="string"),s(typeof e.urlPathname=="string"),s(I(e.urlParsed)),s(e.urlPathname===e.urlParsed.pathname)}function Ar(e,t){const r=t.filter(({filesystemRoot:o})=>e.startsWith(o)).sort(K(({filesystemRoot:o})=>o.length))[0];let i;if(r){const{filesystemRoot:o,urlRoot:l}=r,a={pageId:e,filesystemRoot:o,urlRoot:l};s(l.startsWith("/")&&e.startsWith("/")&&o.startsWith("/"),a),s(e.startsWith(o),a),o!=="/"?(s(!o.endsWith("/"),a),i=$(e,o.length,0)):i=e,s(i.startsWith("/"),a),i=l+(l.endsWith("/")?"":"/")+$(i,1,0)}else i=e;return s(i.startsWith("/")),i=i.split("/").filter(o=>o!=="pages"&&o!=="src"&&o!=="index").join("/"),s(!i.includes(".page.")),s(!i.endsWith(".")),i.endsWith("/index")&&(i=$(i,0,-6)),i===""&&(i="/"),s(i.startsWith("/")),s(!i.endsWith("/")||i==="/"),i}async function jr(e,t,n){kr(t);let r=e(t);if(Rt(r,`The Route Function ${n}`),r=await r,r===!1)return null;if(r===!0&&(r={}),h(I(r),`The Route Function ${n} should return a boolean or a plain JavaScript object (but it's ${p.cyan(`typeof result === ${JSON.stringify(typeof r)}`)} instead)`),"match"in r){const{match:l}=r;if(h(typeof l=="boolean",`The ${p.cyan("match")} value returned by the Route Function ${n} should be a boolean.`),!l)return null}let i=null;"precedence"in r&&(i=r.precedence,h(typeof i=="number",`The ${p.cyan("precedence")} value returned by the Route Function ${n} should be a number.`)),vt(r,`The ${p.cyan("routeParams")} object returned by the Route Function ${n} should`);const o=r.routeParams||{};return h(!("pageContext"in r),`Providing ${p.cyan("pageContext")} in Route Functions is prohibited, see https://vike.dev/route-function#cannot-provide-pagecontext`),s(I(o)),Object.keys(r).forEach(l=>{h(l==="match"||l==="routeParams"||l==="precedence",`The Route Function ${n} returned an object with an unknown property ${p.cyan(l)} (the known properties are ${p.cyan("match")}, ${p.cyan("routeParams")}, and ${p.cyan("precedence")})`)}),{precedence:i,routeParams:o}}function Rt(e,t){R(!Mt(e),`${t} returned a promise, but asynchronous routing is deprecated and will be removed in the next major release, see https://vike.dev/route-function#async`,{onlyOnce:!0})}function Le(){const e=p.cyan("iKnowThePerformanceRisksOfAsyncRouteFunctions");R(!1,`${e} is deprecated and will be removed in the next major release`,{onlyOnce:!0})}function vt(e,t){s(t.endsWith(" should")),y(e,"routeParams")&&(s(t.endsWith(" should")),h(I(e.routeParams),`${t} be a plain JavaScript object.`),h(Yt(e.routeParams),`${t} only hold string values.`))}async function Hr(e,t,n,r){await Promise.all(e.filter(a=>a.fileType===".page.route").map(a=>{var u;return(u=a.loadFile)==null?void 0:u.call(a)}));const{onBeforeRouteHook:i,filesystemRoots:o}=Wr(e,t,n);return{pageRoutes:Lr(o,e,t,r),onBeforeRouteHook:i}}function Lr(e,t,n,r){const i=[];let o=[...r];if(n.length>0){s(e===null);const l=!0;n.filter(a=>!a.isErrorPage).forEach(a=>{const u=a.pageId;o=Br(o,u);let c=null;{const d="route",f=W(a,d);if(f){const g=f.value,m=tt(f.definedAt,d);typeof g=="string"?c={pageId:u,comesFromV1PageConfig:l,routeString:g,routeDefinedAt:m,routeType:"STRING"}:(s(N(g)),W(a,"iKnowThePerformanceRisksOfAsyncRouteFunctions","boolean")&&Le(),c={pageId:u,comesFromV1PageConfig:l,routeFunction:g,routeDefinedAt:m,routeType:"FUNCTION"})}}if(!c){const{routeFilesystem:d}=a;s(d);const{routeString:f,definedBy:g}=d;s(d.routeString.startsWith("/")),c={pageId:u,routeFilesystemDefinedBy:g,comesFromV1PageConfig:l,routeString:f,routeDefinedAt:null,routeType:"FILESYSTEM"}}s(c),i.push(c)})}if(n.length===0){s(e);const l=!1;o.filter(a=>!U(a)).forEach(a=>{const u=t.find(c=>c.pageId===a&&c.fileType===".page.route");if(!u||!("default"in u.fileExports)){const c=Ar(a,e);s(c.startsWith("/")),s(!c.endsWith("/")||c==="/"),i.push({pageId:a,comesFromV1PageConfig:l,routeString:c,routeDefinedAt:null,routeFilesystemDefinedBy:`${a}.page.*`,routeType:"FILESYSTEM"})}else{const{filePath:c,fileExports:d}=u;if(s(d.default),y(d,"default","string")){const f=d.default;h(f.startsWith("/"),`A Route String should start with a leading slash '/' but ${c} has \`export default '${f}'\`. Make sure to \`export default '/${f}'\` instead.`),i.push({pageId:a,comesFromV1PageConfig:l,routeString:f,routeDefinedAt:c,routeType:"STRING"});return}if(y(d,"default","function")){const f=d.default;"iKnowThePerformanceRisksOfAsyncRouteFunctions"in d&&Le(),i.push({pageId:a,comesFromV1PageConfig:l,routeFunction:f,routeDefinedAt:c,routeType:"FUNCTION"});return}h(!1,`The default export of ${c} should be a string or a function.`)}})}return i}function Wr(e,t,n){if(t.length>0)return{onBeforeRouteHook:On(n,"onBeforeRoute"),filesystemRoots:null};let r=null;const i=[];return e.filter(o=>o.fileType===".page.route"&&o.isDefaultPageFile).forEach(({filePath:o,fileExports:l})=>{if(s(l),"onBeforeRoute"in l){h(y(l,"onBeforeRoute","function"),`\`export { onBeforeRoute }\` of ${o} should be a function.`);const{onBeforeRoute:a}=l,u="onBeforeRoute";r={hookFilePath:o,hookFn:a,hookName:u,hookTimeout:te(u)}}"filesystemRoutingRoot"in l&&(h(y(l,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${o} should be a string.`),h(y(l,"filesystemRoutingRoot","string"),`\`export { filesystemRoutingRoot }\` of ${o} is \`'${l.filesystemRoutingRoot}'\` but it should start with a leading slash \`/\`.`),i.push({filesystemRoot:Nr(o),urlRoot:l.filesystemRoutingRoot}))}),{onBeforeRouteHook:r,filesystemRoots:i}}function Nr(e){s(e.startsWith("/")),s(!e.endsWith("/"));const t=e.split("/"),n=$(t,0,-1).join("/")||"/";return s(n.startsWith("/")),s(!n.endsWith("/")||n==="/"),n}function Br(e,t){const{length:n}=e;return e=e.filter(r=>r!==t),s(e.length===n-1),e}function _t(){const e="/";return s(Dr(e)),e}function Dr(e){return e.startsWith("/")}const oe=F("createPageContext.ts",{});async function Ot(e){oe.pageFilesData||(oe.pageFilesData=await ur(!0));const{pageFilesAll:t,allPageIds:n,pageConfigs:r,pageConfigGlobal:i}=oe.pageFilesData,{pageRoutes:o,onBeforeRouteHook:l}=await Hr(t,r,i,n),a=_t();s(ye(a));const c={urlOriginal:e,_objectCreatedByVike:!0,_urlHandler:null,_urlRewrite:null,_baseServer:a,_isProduction:!0,_pageFilesAll:t,_pageConfigs:r,_pageConfigGlobal:i,_allPageIds:n,_pageRoutes:o,_onBeforeRouteHook:l};return Pt(c),c}function Vr(e){const t=e.getAttribute("href");return!!(t===null||t===""||cn(t)||zr(e)||Gr(t)||!Mr(t)||!me(t)||!Ur(e))}function Ur(e){if(Yr()){const n=e.getAttribute("data-vike-link");return n!==null&&n!=="false"}else return!0}function zr(e){const t=e.getAttribute("target"),n=e.getAttribute("rel");return t==="_blank"||t==="_external"||n==="external"||e.hasAttribute("download")}function Gr(e){if(e.startsWith("#"))return!0;const t=n=>n.split("#")[0];return!!(e.includes("#")&&t(e)===t(window.location.href))}function Mr(e){const t=_t();s(ye(t));const{hasBaseServer:n}=V(e,t);return n}function Yr(){return!!window._disableAutomaticLinkInterception}function Jr(e,t){let n=Kr(e,t);return n==="viewport"&&!e._isProduction&&(Ge(!1,"Viewport prefetching is disabled in development",{onlyOnce:!0}),n="hover"),{prefetchStaticAssets:n}}function Kr(e,t){{const n=qr(t);if(n!==null)return n}if("prefetchLinks"in e.exports&&h(!1,"`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead."),"prefetchStaticAssets"in e.exports){const{prefetchStaticAssets:n}=e.exports;if(n===!1)return!1;if(n==="hover")return"hover";if(n==="viewport")return"viewport";const r="prefetchStaticAssets value should be false, 'hover', or 'viewport'";h(I(n),r);const i=Object.keys(n);h(i.length===1&&i[0]==="when",r);const{when:o}=n;if(o==="HOVER"||o==="VIEWPORT"){const l=o.toLowerCase();return R(!1,`prefetchStaticAssets value \`{ when: '${o}' }\` is outdated: set prefetchStaticAssets to '${l}' instead`,{onlyOnce:!0}),l}h(!1,r)}return"hover"}function qr(e){const t=e.getAttribute("data-prefetch-static-assets"),n=e.getAttribute("data-prefetch");if(t===null&&n===null)return null;const r="The attribute data-prefetch is outdated, use data-prefetch-static-assets instead.";if(t){if(h(n===null,r),t==="hover"||t==="viewport")return t;if(t==="false")return!1;h(!1,`data-prefetch-static-assets has value "${t}" but it should instead be "false", "hover", or "viewport"`)}if(n){if(s(!t),R(!1,r,{onlyOnce:!0}),n==="true")return"viewport";if(n==="false")return"hover";h(!1,`data-prefetch has value "${n}" but it should instead be "true" or "false"`)}s(!1)}const Ct=new Map;function Xr(e){const t=Et(e);return Ct.has(t)}function Qr(e){const t=Et(e);Ct.set(t,!0)}function Et(e){return V(e,"/").pathname}function B(e){return e.fileType===".css"?[]:e.exportNames?e.exportNames:(s(e.fileExports,e.filePath),Object.keys(e.fileExports))}function Zr({pageFilesClientSide:e,pageFilesServerSide:t,pageId:n}){return{isHtmlOnly:r(),isClientRouting:o()};function r(){return t.some(a=>a.pageId===n&&a.fileType===".page")?(i(),!1):!(!t.some(a=>a.pageId===n&&a.fileType===".page.server")||e.some(a=>a.pageId===n&&a.fileType===".page.client"&&B(a).includes("render")))}function i(){const l=e.some(a=>B(a).includes("render"));h(l,["No client-side `render()` hook found.","See https://vike.dev/render-modes for more information.",["Loaded client-side page files (none of them `export { render }`):",...e.map((a,u)=>` (${u+1}): ${a.filePath}`)].join(`
`)].join(" "))}function o(){return e.some(a=>B(a).includes("clientRouting"))}}function ei({pageFilesClientSide:e,pageFilesServerSide:t,isHtmlOnly:n,isClientRouting:r}){let i=[];const o=t.filter(a=>!e.includes(a)),l=[];if(l.push(...e.map(a=>({id:a.filePath,onlyAssets:!1,eagerlyImported:!1}))),l.push(...o.map(a=>({id:a.filePath,onlyAssets:!0,eagerlyImported:!1}))),n)i=e.map(a=>a.filePath);else{const a=ti(r);l.push({id:a,onlyAssets:!1,eagerlyImported:!1}),i=[a]}return{clientEntries:i,clientDependencies:l}}function ti(e){return e?"@@vike/dist/esm/client/client-routing-runtime/entry.js":"@@vike/dist/esm/client/server-routing-runtime/entry.js"}function ni(e,t){let n=Pe(e,t);const r=Qe(e,t),{isHtmlOnly:i,isClientRouting:o}=Zr({pageFilesClientSide:n,pageFilesServerSide:r,pageId:t});i&&(n=n.filter(u=>u.isEnv("CLIENT_ONLY")&&!B(u).includes("render")),n=ii(n));const{clientEntries:l,clientDependencies:a}=ei({pageFilesClientSide:n,pageFilesServerSide:r,isHtmlOnly:i,isClientRouting:o});return{isHtmlOnly:i,isClientRouting:o,clientEntries:l,clientDependencies:a,pageFilesClientSide:n,pageFilesServerSide:r}}async function ri(e,t,{sharedPageFilesAlreadyLoaded:n}){const r=Pe(e,t);await Promise.all(r.map(async i=>{var o;s(i.isEnv("CLIENT_ONLY")||i.isEnv("CLIENT_AND_SERVER")),!(n&&i.isEnv("CLIENT_AND_SERVER"))&&await((o=i.loadExportNames)==null?void 0:o.call(i))}))}function ii(e){const t=[];for(const n of e)if(t.push(n),B(n).includes("overrideDefaultPages"))break;return t}function oi(e,t,n){var r,i;if(e){const o=((r=W(e,"clientRouting","boolean"))==null?void 0:r.value)??!1;return{isClientSideRenderable:((i=W(e,"isClientSideRenderable","boolean"))==null?void 0:i.value)??!1,isClientRouting:o}}else{const{isHtmlOnly:o,isClientRouting:l}=ni(t,n);return{isClientSideRenderable:!o,isClientRouting:l}}}async function $t(e,t){await ri(t._pageFilesAll,e,{sharedPageFilesAlreadyLoaded:!1});const n=ct(t._pageConfigs,e),{isClientSideRenderable:r,isClientRouting:i}=oi(n,t._pageFilesAll,e);return r&&i}const Ft="@",ce=":";function si(e,t="Invalid"){let n=`${t} Route String ${A(e)}`;h(e!=="",`${n} (empty string): set it to ${A("/")} instead`),h(["/","*"].includes(e[0]),`${n}: it should start with ${A("/")} or ${A("*")}`),h(!e.includes("**"),`${n}: set it to ${A(e.split("**").join("*"))} instead`)}function fe(e,t){si(e);const n=xt(e),r=n.map(f=>f.param?"[^/]+":f.glob?f.isLastDir?"|/.*":".*":yn(f.static)).map(f=>`(${f})`).join(""),i=new RegExp(`^${r}/?$`),o=t.match(i);if(!o)return null;const l={},[a,...u]=o;let c=0;const d=n.filter(f=>f.glob).length>1;return n.forEach((f,g)=>{let m=u[g];if(f.param&&(l[f.param]=m),f.glob){const S=`*${d?++c:""}`;f.isLastDir&&(m=m.slice(1)),l[S]=m}}),{routeParams:l}}function xt(e){const t=[],n=i=>{const o=t[t.length-1];o!=null&&o.static?o.static+=i:t.push({static:i})},r=e.split("/");return r.forEach((i,o)=>{const l=o===0,a=o===r.length-1;ai(i)?(R(!i.startsWith(ce),`Outdated Route String ${A(e)}, use ${A(e.split(ce).join(Ft))} instead`,{onlyOnce:!0}),l||n("/"),t.push({param:i.slice(1)})):i==="*"&&a&&e!=="*"&&e!=="/*"?t.push({glob:!0,isLastDir:!0}):(l||n("/"),i.split("*").forEach((u,c)=>{c!==0&&t.push({glob:!0}),u!==""&&n(u)}))}),t}function Y(e){const t=xt(e),n=a=>(a==null?void 0:a.split("/").filter(Boolean).length)||0;let r=0;for(const a of t){if(!a.static)break;r+=n(a.static)}const i=t.map(a=>n(a.static)).reduce((a,u)=>a+u,0),o=t.filter(a=>a.param).length,l=t.filter(a=>a.glob).length;return{numberOfStaticPartsBeginning:r,numberOfStaticParts:i,numberOfParams:o,numberOfGlobs:l}}function ai(e){return e.startsWith(Ft)||e.startsWith(ce)}function We(e){const n=fe(e,e);return s(n),Object.keys(n.routeParams).length===0}function A(e){return D()?`'${e}'`:(e===""&&(e="''"),p.cyan(e))}function li(e){e.sort(ui).sort(k(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence<0)).sort(k(t=>t.routeType==="STRING"&&We(t.routeString)===!1)).sort(k(t=>t.routeType==="FUNCTION"&&!t.precedence)).sort(k(t=>t.routeType==="STRING"&&We(t.routeString)===!0)).sort(k(t=>t.routeType==="FILESYSTEM")).sort(k(t=>t.routeType==="FUNCTION"&&!!t.precedence&&t.precedence>0))}function ui(e,t){{const n=e.precedence??0,r=t.precedence??0;if(n!==r)return n>r?-1:1}if(!t.routeString||!e.routeString)return 0;{const r=K(i=>Y(i).numberOfStaticPartsBeginning)(e.routeString,t.routeString);if(r!==0)return r}{const r=K(i=>Y(i).numberOfStaticParts)(e.routeString,t.routeString);if(r!==0)return r}{const r=zt(i=>Y(i).numberOfGlobs)(e.routeString,t.routeString);if(r!==0)return r}{const r=K(i=>Y(i).numberOfParams)(e.routeString,t.routeString);if(r!==0)return r}return 0}async function ci(e){const t={};if(!e._onBeforeRouteHook)return null;const n=await fi(e._onBeforeRouteHook,e);return n&&(P(t,n),y(t,"_pageId","string")||y(t,"_pageId","null"))?(y(t,"routeParams")?s(y(t,"routeParams","object")):P(t,{routeParams:{}}),P(t,{_routingProvidedByOnBeforeRouteHook:!0,_debugRouteMatches:"CUSTOM_ROUTING"}),t):(P(t,{_routingProvidedByOnBeforeRouteHook:!1}),t)}async function fi(e,t){let n=e.hookFn(t);Rt(n,`The onBeforeRoute() hook ${e.hookFilePath}`),n=await j(()=>n,e);const r=`The onBeforeRoute() hook defined by ${e.hookFilePath}`;if(h(n==null||Ut(n,["pageContext"])&&y(n,"pageContext"),`${r} should return ${p.cyan("null")}, ${p.cyan("undefined")}, or a plain JavaScript object ${p.cyan("{ pageContext: { /* ... */ } }")}`),n==null)return null;if(h(y(n,"pageContext","object"),`${r} returned ${p.cyan("{ pageContext }")} but pageContext should be a plain JavaScript object.`),y(n.pageContext,"_pageId")&&!y(n.pageContext,"_pageId","null")){const l=`${r} returned ${p.cyan("{ pageContext: { _pageId } }")} but ${p.cyan("_pageId")} should be`;h(y(n.pageContext,"_pageId","string"),`${l} a string or null`),h(t._allPageIds.includes(n.pageContext._pageId),`${l} ${Nt(t._allPageIds.map(a=>p.cyan(a)),"or")}`)}y(n.pageContext,"routeParams")&&vt(n.pageContext,`${r} returned ${p.cyan("{ pageContext: { routeParams } }")} but routeParams should`);const i=l=>`${r} returned ${p.cyan(`{ pageContext: { ${l} } }`)} which is deprecated. Return ${p.cyan("{ pageContext: { urlLogical } }")} instead.`;y(n.pageContext,"url")&&(R(!1,i("url"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.url,delete n.pageContext.url),y(n.pageContext,"urlOriginal")&&(R(!1,i("urlOriginal"),{onlyOnce:!0}),n.pageContext.urlLogical=n.pageContext.urlOriginal,delete n.pageContext.urlOriginal),y(n.pageContext,"urlLogical")&&Jt(n.pageContext.urlLogical,`${r} returned ${p.cyan("{ pageContext: { urlLogical } }")} but ${p.cyan("urlLogical")}`),gt(n.pageContext,{hookFilePath:e.hookFilePath,hookName:"onBeforeRoute"});const o={};return P(o,n.pageContext),o}var J;function Ne(...e){var t;J||(J=(t=globalThis.__brillout_debug_createDebugger)==null?void 0:t.call(globalThis,"vike:routing")),J&&J(...e)}D()&&pe();async function Tt(e){Ne("Pages routes:",e._pageRoutes),Pt(e);const t={},n=await ci(e);if(n){if(n._routingProvidedByOnBeforeRouteHook)return s(n._pageId),n;P(t,n)}const r={};P(r,e),P(r,n);const i=r._allPageIds;s(i.length>=0),h(r._pageFilesAll.length>0||r._pageConfigs.length>0,"No *.page.js file found. You must create at least one *.page.js file."),h(i.length>0,"You must create at least one *.page.js file that isn't _default.page.*");const{urlPathname:o}=r;s(o.startsWith("/"));const l=[];await Promise.all(r._pageRoutes.map(async u=>{const{pageId:c,routeType:d}=u;if(u.routeType==="FILESYSTEM"){const{routeString:f}=u,g=fe(f,o);if(g){const{routeParams:m}=g;l.push({pageId:c,routeParams:m,routeString:f,routeType:d})}return}if(u.routeType==="STRING"){const{routeString:f}=u,g=fe(f,o);if(g){const{routeParams:m}=g;s(d==="STRING"),l.push({pageId:c,routeString:f,routeParams:m,routeType:d})}return}if(u.routeType==="FUNCTION"){const{routeFunction:f,routeDefinedAt:g}=u,m=await jr(f,r,g);if(m){const{routeParams:S,precedence:C}=m;l.push({pageId:c,precedence:C,routeParams:S,routeType:d})}return}s(!1)})),li(l);const a=l[0];if(Ne(`Route matches for URL ${p.cyan(o)} (in precedence order):`,l),P(t,{_debugRouteMatches:l}),!a)return P(t,{_pageId:null,routeParams:{}}),t;{const{routeParams:u}=a;s(I(u)),P(t,{_pageId:a.pageId,routeParams:a.routeParams})}return t}pe();const Be=F("prefetch.ts",{linkPrefetchHandlerAdded:new Map});async function di(e,t){try{await Q(e,t)}catch(n){if(Re(n))he(n,!0);else throw n}}function gi(e){Qr(e.urlPathname),[...document.getElementsByTagName("A")].forEach(n=>{if(Be.linkPrefetchHandlerAdded.has(n))return;Be.linkPrefetchHandlerAdded.set(n,!0);const r=n.getAttribute("href");if(Vr(n)||(s(r),Xr(r)))return;const{prefetchStaticAssets:i}=Jr(e,n);if(i&&(i==="hover"&&(n.addEventListener("mouseover",()=>{se(r)}),n.addEventListener("touchstart",()=>{se(r)},{passive:!0})),i==="viewport")){const o=new IntersectionObserver(l=>{l.forEach(a=>{a.isIntersecting&&(se(r),o.disconnect())})});o.observe(n)}})}async function se(e){const t=await Ot(e);let n;try{n=await Tt(t)}catch{return}n!=null&&n._pageId&&await $t(n._pageId,t)&&await di(n._pageId,t)}async function hi(e,t){const n=we(e,t);let r=null,i;r=T(e,"render"),i="render";{const a=T(e,"onRenderClient");a&&(r=a,i="onRenderClient")}if(!r){const a=pi(e);if(s(a),e._pageConfigs.length>0)h(!1,`No onRenderClient() hook defined for URL '${a}', but it's needed, see https://vike.dev/onRenderClient`);else{const u=e._pageFilesLoaded.filter(d=>d.fileType===".page.client");let c;u.length===0?c="No file `*.page.client.*` found for URL "+a:c="One of the following files should export a render() hook: "+u.map(d=>d.filePath).join(" "),h(!1,c)}}s(r);const o=r.hookFn;s(i);const l=await j(()=>o(n),r);h(l===void 0,`The ${i}() hook defined by ${r.hookFilePath} isn't allowed to return a value`)}function pi(e){let t;try{t=e.urlPathname??e.urlOriginal}catch{}return t=t??window.location.href,t}const de=F("history.ts",{});function mi(){let e=window.history.state;e||(e={});let t=!1;"timestamp"in e||(t=!0,e.timestamp=Oe()),"scrollPosition"in e||(t=!0,e.scrollPosition=_e()),"triggedBy"in e||(e.triggedBy="browser"),It(e),t&&Ce(e)}function ve(){const e=window.history.state||{};return It(e),e}function _e(){return{x:window.scrollX,y:window.scrollY}}function Oe(){return new Date().getTime()}function De(){const e=_e(),t=ve();Ce({...t,scrollPosition:e})}function yi(e,t){if(t)Ce(ve(),e);else{const n=Oe();bi({timestamp:n,scrollPosition:null,triggedBy:"vike"},e)}}function It(e){if(s(v(e)),"timestamp"in e){const{timestamp:t}=e;s(typeof t=="number")}if("scrollPosition"in e){const{scrollPosition:t}=e;t!==null&&s(y(t,"x","number")&&y(t,"y","number"))}}function Ce(e,t){window.history.replaceState(e,"",t??null)}function bi(e,t){kt(e,"",t)}function $i(){de.pushStateOriginal=de.pushStateOriginal??window.history.pushState,window.history.pushState=(e={},...t)=>{h(e==null||v(e),"history.pushState(state) argument state must be an object");const n={scrollPosition:_e(),timestamp:Oe(),...e,triggedBy:"user"};return kt(n,...t)}}function kt(...e){de.pushStateOriginal.apply(history,e)}function At(e){if(e==="preserve-scroll")return;let t;if(e==="scroll-to-top-or-hash"){const n=Si();if(n&&n!=="top"){const r=document.getElementById(n)||document.getElementsByName(n)[0];if(r){r.scrollIntoView();return}}t={x:0,y:0}}else s("x"in e&&"y"in e),t=e;Pi(t)}function Pi(e){const t=()=>window.scrollTo(e.x,e.y),n=()=>window.scrollX===e.x&&window.scrollY===e.y;n()||(t(),!n()&&requestAnimationFrame(()=>{t(),!n()&&setTimeout(async()=>{if(t(),n())return;const r=new Date().getTime();for(;;)if(await an(10),t(),n()||new Date().getTime()-r>100)return},0)}))}function Si(){let{hash:e}=window.location;return e===""?null:(s(e.startsWith("#")),e=e.slice(1),e)}function Fi(){window.addEventListener("scroll",ln(De,Math.ceil(1e3/3)),{passive:!0}),Ke(De)}const H=F("onBrowserHistoryNavigation.ts",{previousState:Z()});function xi(){window.addEventListener("popstate",e=>{const t=Z(),n=t.historyState.scrollPosition||"scroll-to-top-or-hash",r=t.historyState.triggedBy==="user",i=t.urlWithoutHash===H.previousState.urlWithoutHash,o=!t.historyState.timestamp||!H.previousState.historyState.timestamp?null:t.historyState.timestamp<H.previousState.historyState.timestamp;H.previousState=t,i&&!r?window.history.state===null?(mi(),H.previousState=Z()):At(n):ge({scrollTarget:n,isBackwardNavigation:o,isUserLandPushStateNavigation:r})})}function Z(){return{urlWithoutHash:be({withoutHash:!0}),historyState:ve()}}function wi(){H.previousState=Z()}const jt=F("scrollRestoration.ts",{});function Ti(){Ve(),Ke(Ve),un(()=>jt.initialRenderIsDone&&Ee())}function Ri(){jt.initialRenderIsDone=!0}function Ee(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual")}function Ve(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="auto")}const w=F("renderPageClientSide.ts",{renderCounter:0});async function ge(e){var $e;const{scrollTarget:t,urlOriginal:n=be(),overwriteLastHistoryEntry:r=!1,isBackwardNavigation:i,pageContextsFromRewrite:o=[],redirectCount:l=0,isUserLandPushStateNavigation:a,isClientSideNavigation:u=!0}=e,{abortRender:c,setHydrationCanBeAborted:d,isFirstRender:f}=Oi();if(s(u===!f),Bt(o.length,l),w.clientRoutingIsDisabled){q(n);return}const g=await Ot(n);if(c())return;P(g,{isBackwardNavigation:i,isClientSideNavigation:u});{const b=Dt(o);P(g,b)}let m={};const S=b=>{s(b),s(!("err"in m)),s(!("errorWhileRendering"in g)),m.err=b,g.errorWhileRendering=b};if(!f){try{m={pageContextFromRoute:await Tt(g)}}catch(b){S(b)}if(c())return;if(m.pageContextFromRoute){const{pageContextFromRoute:b}=m;P(g,b);let _;if(!b._pageId)_=!1;else if(_=await $t(b._pageId,g),c())return;if(!_){q(n);return}const E=b._pageId&&(($e=w.previousPageContext)==null?void 0:$e._pageId)&&b._pageId===w.previousPageContext._pageId;if(a&&E)return}}const C=!f;if(C&&!w.isTransitioning){if(w.onPageTransitionStart){const b=w.onPageTransitionStart,{hookFn:_}=b;await j(()=>_(g),b)}if(w.isTransitioning=!0,c())return}if(f){s(!m.pageContextFromRoute),s(!m.err);try{m.pageContextFromHooks=await vr(g)}catch(b){S(b)}if(c())return}else if(!m.err){const{pageContextFromRoute:b}=m;s(b),s(b._pageId),s(y(b,"_pageId","string")),P(g,b);try{m.pageContextFromHooks=await Or(g)}catch(_){S(_)}if(c())return}if("err"in m){const{err:b}=m;if(Fe(b)||console.error(b),Ue(b,g,f))return;if(Fe(b)){const _=b;Vt(b,g._isProduction,g);const E=_._pageContextAbort;if(E._urlRewrite){await ge({...e,scrollTarget:"scroll-to-top-or-hash",pageContextsFromRewrite:[...o,E]});return}if(E._urlRedirect){const ne=E._urlRedirect.url;if(ne.startsWith("http")){window.location.href=ne;return}else await ge({...e,scrollTarget:"scroll-to-top-or-hash",urlOriginal:ne,overwriteLastHistoryEntry:!1,isBackwardNavigation:!1,redirectCount:l+1});return}s(E.abortStatusCode),P(g,E),E.abortStatusCode===404&&P(g,{is404:!0})}else P(g,{is404:!1});try{m.pageContextFromHooks=await _r(g)}catch(_){if(Ue(_,g,f)||(f||setTimeout(()=>{window.location.pathname=n},0),sn(b,_)))return;throw _}if(c())return}const{pageContextFromHooks:O}=m;s(O),P(g,O),ie(g,"onPageTransitionStart");const z=T(g,"onPageTransitionStart");if(w.onPageTransitionStart=z,g.exports.hydrationCanBeAborted?d():R(!on(),"You seem to be using React; we recommend setting hydrationCanBeAborted to true, see https://vike.dev/hydrationCanBeAborted",{onlyOnce:!0}),!c()&&!(w.renderPromise&&(await w.renderPromise,s(w.renderPromise===void 0),c()))){if(vi(n,r),w.previousPageContext=g,s(w.renderPromise===void 0),w.renderPromise=(async()=>{await hi(g,!0),gi(g),w.renderPromise=void 0})(),await w.renderPromise,s(w.renderPromise===void 0),f){ie(g,"onHydrationEnd");const b=T(g,"onHydrationEnd");if(b){const{hookFn:_}=b;if(await j(()=>_(g),b),c(!0))return}}if(!c(!0)){if(C){ie(g,"onPageTransitionEnd");const b=T(g,"onPageTransitionEnd");if(b){const{hookFn:_}=b;if(await j(()=>_(g),b),c(!0))return}w.isTransitioning=void 0}At(t),Ee(),Ri()}}}function vi(e,t){be()!==e&&(Ee(),yi(e,t),wi())}function Ue(e,t,n){return!!(Fr(e)||_i(e,t,n))}function _i(e,t,n){if(!Re(e))return!1;if(n)throw he(e,!1),e;return he(e,!0),q(t.urlOriginal),!0}function he(e,t){s(Re(e)),w.clientRoutingIsDisabled=!0,t&&console.log(e),Ge(!1,["Failed to fetch static asset.","This usually happens when a new frontend is deployed.","Falling back to Server Routing.","(The next page navigation will use Server Routing instead of Client Routing.)"].filter(Boolean).join(" "),{onlyOnce:!0})}function Oi(){const e=++w.renderCounter;s(e>=1);let t=!1;return{abortRender:i=>!i&&e===1&&!t?!1:e!==w.renderCounter,setHydrationCanBeAborted:()=>{t=!0},isFirstRender:e===1}}function Ii(){return w.renderCounter}export{fe as a,Vr as b,Ti as c,Fi as d,Ii as g,mi as i,$i as m,xi as o,ge as r,Ei as s};
